# Урок: поиск, фильтрация и сортировка товаров (Laravel)

Цель: сделать страницу каталога `/products` удобной для пользователя:
- поиск (по названию и артикулу),
- фильтр по цене (от/до),
- фильтр «только в наличии»,
- сортировка,
- пагинация, которая не сбрасывает фильтры.

Реализация построена на простом и понятном разделении ответственности:
- `routes` → куда попадает запрос,
- `FormRequest` → какие параметры разрешены и как их проверять,
- `DTO` → единый объект параметров фильтра,
- `Service` → построение Eloquent-запроса (поиск/фильтры/сортировка/пагинация),
- `Blade` → форма фильтра и список товаров.

Ниже разбор по файлам, которые были изменены.

---

## Как работает поток запроса (очень важно понять)

Когда пользователь открывает, например, `/products?q=iphone&sort=price_desc`, происходит следующее:

1. Браузер отправляет **GET** запрос на сервер: `/products` + query string.
2. Laravel находит маршрут в `routes/web.php` и вызывает нужный метод контроллера.
3. Laravel создаёт `ProductFilterRequest` и проверяет query‑параметры по правилам (`rules()`).
4. Мы собираем `ProductFilterDto` из валидированных данных.
5. `ProductService` строит Eloquent‑запрос к таблице `products` (поиск/фильтры/сортировка).
6. `paginate()` возвращает пагинатор, и Blade рендерит HTML.

Это «правильный» учебный шаблон: каждый слой отвечает только за своё.

---

## Какие параметры поддерживаем (памятка)

Все параметры приходят в URL, потому что форма отправляется методом **GET**:

| Параметр | Пример | Что делает |
|---|---|---|
| `q` | `q=iphone` | поиск по `name` и `sku` |
| `min_price` | `min_price=1000` | цена `>=` |
| `max_price` | `max_price=5000` | цена `<=` |
| `in_stock` | `in_stock=1` | только товары со `stock > 0` |
| `sort` | `sort=price_desc` | сортировка из белого списка |
| `per_page` | `per_page=50` | сколько товаров на странице |

---

## 1) Маршруты: куда приходят запросы

Файл: `routes/web.php`

- `Route::get('/products', ...)` — список товаров (каталог).
- `Route::get('/products/{product}', ...)` — страница товара.
- Дополнительно: `Route::view('/', 'main')->name('home');`
  - Это главная страница без контроллера: просто отдаём view.
  - Практическая польза: есть рабочая точка входа `/` и корректная навигация.

---

## 2) Контроллер: склеиваем слои, но не «живём» в нём

Файл: `app/Http/Controllers/ProductController.php`

Идея для начинающих: контроллер должен быть «тонким». Он организует поток, но не содержит тяжёлой логики:
1) принять запрос,
2) подготовить параметры,
3) вызвать сервис,
4) вернуть view.

В `index()`:
- `ProductFilterDto::fromRequest($request)` собирает параметры фильтра в объект.
- `ProductService::getProducts($dto)` возвращает уже отфильтрованный и отсортированный список.
- `ProductService::getMaxProductPrice()` возвращает максимальную цену для подсказки в поле `max_price`.

---

## 3) FormRequest: правила для query-параметров

Файл: `app/Http/Requests/ProductFilterRequest.php`

`FormRequest` нужен, чтобы:
- держать правила валидации в одном месте,
- гарантировать, что в сервис попадут только разрешённые значения.

Параметры:
- `per_page` — только `10, 25, 50, 100` (защита от слишком больших страниц).
- `q` — строка до 255 символов.
- `min_price`, `max_price` — число `>= 0`.
- `in_stock` — boolean.
- `sort` — только из белого списка (`new`, `price_asc`, ...).

Почему белый список важен:
сортировка управляет `orderBy`, а `orderBy` нельзя строить из произвольного пользовательского ввода.

---

## 4) DTO: один объект параметров вместо множества переменных

Файл: `app/DTO/ProductFilterDto.php`

DTO хранит параметры фильтра:
- `per_page`, `q`, `min_price`, `max_price`, `in_stock`, `sort`.

Сборка DTO делается из `$request->validated()` — то есть только из данных, прошедших правила.

Отдельно: `in_stock` берётся через `$request->boolean('in_stock')`,
чтобы чекбокс из формы стал настоящим `true/false`.

---

## 5) Service: поиск, фильтрация, сортировка, пагинация

Файл: `app/Service/ProductService.php`

### 5.1) Максимальная цена (для подсказки в форме)

`getMaxProductPrice()` делает агрегатный запрос `MAX(price)`.
Это +1 запрос к БД на страницу каталога, но для учебного проекта и небольшого каталога — нормально.

### 5.2) Построение запроса каталога

`getProducts(ProductFilterDto $dto)`:

1) Стартуем запрос: `Product::query()`.
2) Поиск (если `q` не пустой):
   - `name LIKE '%q%'` или `sku LIKE '%q%'`.
3) Фильтр по цене:
   - если задан `min_price` → `price >= min_price`
   - если задан `max_price` → `price <= max_price`
4) Фильтр «в наличии»:
   - если `in_stock = true` → `stock > 0`
5) Сортировка:
   - через `switch ($dto->sort)` и фиксированные варианты.
6) Пагинация:
   - `paginate($perPage)->withQueryString()`
   - `withQueryString()` сохраняет фильтры при переходе по страницам.

Примечание про поиск и символы `%` и `_`:
в SQL это специальные символы для `LIKE`. В учебной версии мы оставили всё максимально просто.
Если захотите «строгий поиск», можно экранировать ввод (это уже отдельная тема).

---

## 6) Blade: форма фильтров и вывод товаров

Файл: `resources/views/products/index.blade.php`

### Почему `GET`

Форма сделана методом `GET`, потому что:
- фильтры видны в URL,
- ссылкой можно делиться,
- пагинация «естественно» работает с query string.

### Сохранение выбранных значений

Значения для формы берутся из `$dto` — поэтому после отправки формы поля не «обнуляются».

### Подсказки (placeholder)

- `min_price` — `placeholder="от 100"`.
- `max_price` — вычисляется на основе максимальной цены из БД:
  - если цена есть → например `до 19990`
  - иначе → `максимальная цена товара`

### Пагинация

Используем `{{ $products->links('pagination::bootstrap-5') }}`.
Фильтры сохраняются, потому что в сервисе используется `withQueryString()`.

---

## 7) Layout: где показывать вход/регистрацию/профиль/выход

Файл: `resources/views/layouts/app.blade.php`

Шапка (`navbar`) — лучшее место для кнопок авторизации, потому что это общий layout для всех страниц.

- `@guest` показывает ссылки «Вход» и «Регистрация».
- `@auth` показывает «Профиль» и кнопку «Выход».

Почему «Выход» — через POST форму:
по практике веб-безопасности logout делают POST + CSRF.

---

## 8) Главная страница (вспомогательное)

Файл: `resources/views/main.blade.php`

Кнопка «Каталог товаров» ведёт на `route('products.index')`.

---

## Проверка вручную (примеры URL)

- `/products`
- `/products?q=iphone`
- `/products?q=sku-001`
- `/products?min_price=1000&max_price=5000`
- `/products?in_stock=1`
- `/products?sort=price_desc`
- `/products?per_page=50`
- `/products?q=iphone&min_price=1000&sort=price_asc&in_stock=1`

---

## Упражнения

1) Добавить фильтр по минимальному остатку (`min_stock`).
2) Добавить текст «Найдено: N» (использовать `$products->total()`).
3) Добавить фильтр по категории (если появится таблица категорий).
